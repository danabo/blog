<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.80.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Modular Neural Networks&nbsp;&ndash;&nbsp;Dan&#39;s Notepad</title><link rel="stylesheet" href="https://danabo.github.io/blog/css/core.min.663c1b913e8f8da65500ac57052b0c8dffe91fbf55bc616423803d94b150f74f29bf3c72fca9922bcbb8cd97c17e8532.css" integrity="sha384-ZjwbkT6PjaZVAKxXBSsMjf/pH79VvGFkI4A9lLFQ908pvzxy/KmSK8u4zZfBfoUy"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Modular Neural Networks" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="https://danabo.github.io/blog/"><span class="site name">Dan's Notepad</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="https://danabo.github.io/blog/tags/">Tags</a><a class="nav item" href=""></a><a class="nav item" href="https://zhat%2eio/"target="_blank">Zhat</a></nav></div></span></div><div class="site slogan"><span class="title">A window into my second brain</span></div></section><section id="content"><div class="article-outer">
    <div class="article-container"><section class="article header">
    <h1 class="article title">Modular Neural Networks</h1><p class="article date">April 13, 2021</p></section><article class="article markdown-body"><p>$$<br>
\newcommand{\0}{\mathrm{false}}<br>
\newcommand{\1}{\mathrm{true}}<br>
\newcommand{\mb}{\mathbb}<br>
\newcommand{\mc}{\mathcal}<br>
\newcommand{\mf}{\mathfrak}<br>
\newcommand{\and}{\wedge}<br>
\newcommand{\or}{\vee}<br>
\newcommand{\a}{\alpha}<br>
\newcommand{\s}{\sigma}<br>
\newcommand{\t}{\theta}<br>
\newcommand{\T}{\Theta}<br>
\newcommand{\D}{\Delta}<br>
\newcommand{\o}{\omega}<br>
\newcommand{\O}{\Omega}<br>
\newcommand{\x}{\xi}<br>
\newcommand{\z}{\zeta}<br>
\newcommand{\fa}{\forall}<br>
\newcommand{\ex}{\exists}<br>
\newcommand{\X}{\mc{X}}<br>
\newcommand{\Y}{\mc{Y}}<br>
\newcommand{\Z}{\mc{Z}}<br>
\newcommand{\P}{\Psi}<br>
\newcommand{\y}{\psi}<br>
\newcommand{\p}{\phi}<br>
\newcommand{\l}{\lambda}<br>
\newcommand{\B}{\mb{B}}<br>
\newcommand{\m}{\times}<br>
\newcommand{\E}{\mb{E}}<br>
\newcommand{\H}{\mb{H}}<br>
\newcommand{\I}{\mb{I}}<br>
\newcommand{\R}{\mb{R}}<br>
\newcommand{\e}{\varepsilon}<br>
\newcommand{\set}[1]{\left\{#1\right\}}<br>
\newcommand{\par}[1]{\left(#1\right)}<br>
\newcommand{\abs}[1]{\left\lvert#1\right\rvert}<br>
\newcommand{\inv}[1]{{#1}^{-1}}<br>
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}<br>
\newcommand{\dom}[2]{#1_{\mid #2}}<br>
\newcommand{\df}{\overset{\mathrm{def}}{=}}<br>
\newcommand{\M}{\mc{M}}<br>
\newcommand{\up}[1]{^{(#1)}}<br>
$$</p>
<p>I wrote up these notes in preparation for my guest lecture in Tom Dean&rsquo;s Stanford course, <a href="https://web.stanford.edu/class/cs379c/"target="_blank">CS379C: Computational Models of the Neocortex</a>.</p>
<p>Selected papers</p>
<ul>
<li><a href="https://arxiv.org/abs/2003.04227"target="_blank">Towards Modular Algorithm Induction</a> (Abolafia et al.)</li>
<li><a href="https://arxiv.org/abs/1811.05249"target="_blank">Modular Networks: Learning to Decompose Neural Computation</a> (Kirsch et al.)</li>
</ul>
<h1 id="what">What?</h1>
<p>What do the phrases &ldquo;modular architectures&rdquo; and &ldquo;learning modular structures&rdquo; mean?</p>
<p>In programming, a module is a reusable function. Modularity is a design principle, where code is composed of smaller functions which have well defined behavior in isolation, so that the system can be understood by looking at its parts (i.e. <a href="https://en.wikipedia.org/wiki/Reductionism#In_science"target="_blank">reduction</a>).</p>
<p>Modular code satisfies:</p>
<ul>
<li><strong>Isolation</strong>: The internal behavior of one module doesn&rsquo;t affect other modules.</li>
<li><strong>Reusability</strong>: The same module applied in different circumstances, potentially given different kinds of data that follow the same pattern (think <a href="https://en.wikipedia.org/wiki/Generic_programming"target="_blank">generics</a> and <a href="https://en.wikipedia.org/wiki/Abstract_type"target="_blank">abstract types</a>).</li>
</ul>
<p>In the context of machine learning, a modular neural architecture is a type of neural network composed of smaller neural modules. If data can be said to contain modular structure (e.g. see <a href="https://arxiv.org/abs/1902.07181"target="_blank">Andreas 2019</a>), then one goal of modular neural networks is to recover that latent structure.</p>
<p>Pictorial examples of modular neural networks:</p>
<p>

  <img src="https://danabo.github.io/blog/Pasted%20image%2020210413141842.png" alt="">
{<a href="https://arxiv.org/abs/1811.05249"target="_blank">Kirsch et al.</a>}</p>
<p>

  <img src="https://danabo.github.io/blog/Pasted%20image%2020210413141514.png" alt="">
{<a href="https://arxiv.org/abs/1807.04640"target="_blank">Chang et al.</a>}</p>
<p>

  <img src="https://danabo.github.io/blog/Pasted%20image%2020210413141932.png" alt="">
{<a href="https://arxiv.org/abs/2003.04227"target="_blank">Abolafia et al.</a>}</p>
<h1 id="why">Why?</h1>
<p>Why have modular neural architectures? Is it beneficial for program synthesis? Is it beneficial for machine learning in general?</p>
<h2 id="data-invariances">Data invariances</h2>
<p><a href="https://arxiv.org/abs/1806.06765"target="_blank">Modularity Matters: Learning Invariant Relational Reasoning Tasks</a>  (Jo et al.)</p>
<blockquote>
<p>When a dataset has a large number of invariances, a machine learning model must learn to associate a large number of seemingly unrelated patterns with one another, which may exacerbate the interference problem &hellip; One natural way to combat the interference problem is to allow for specialized sub-modules in our architecture. Once we modularize, we reduce the amount of interference that can occur between features in our model. These specialized modules can now learn highly discriminative yet invariant representations while not interfering with each other.</p>
</blockquote>
<h2 id="strong-generalization">Strong generalization</h2>
<p>Strong generalization means getting the right answer for an input/task that is very different from the training regime. Sometimes this is called zero-shot learning. Humans seem to be able to this. How does it work?</p>
<p><a href="https://arxiv.org/abs/1609.07088"target="_blank">Learning Modular Neural Network Policies for Multi-Task and Multi-Robot Transfer</a> (Devin et al.)</p>
<p>

  <figure>
    
    <img src="https://danabo.github.io/blog/Pasted%20image%2020210413144242.png" alt="">
    <figcaption>The robot and task networks are trained end-to-end on different robot-task combinations, with some held out. For example, during training this system does not encounter robot 2 combined with task 2, but does encounter robot 2 and task 2 separately in different situations. At test time, the system has to perform well when robot 2 is combined with task 2.</figcaption>
  </figure>
</p>
<p><a href="https://arxiv.org/abs/1611.01796"target="_blank">Modular Multitask Reinforcement Learning with Policy Sketches</a> (Andreas 2016)</p>
<blockquote>
<p>The modular structure of our approach, which associates every high-level action symbol with a discrete subpolicy,naturally induces a library of interpretable policy fragments that are easily recombined. This makes it possible to evaluate our approach under a variety of different data conditions: (1) learning the full collection of tasks jointly via reinforcement, (2) in a zero-shot setting where a policy sketch is available for a held-out task, and (3) in a adaptation setting, where sketches are hidden and the agent must learn to adapt a pretrained policy to reuse high-level actions in a new task.</p>
</blockquote>
<blockquote>
<p>&hellip; we have shown that it is possible to build agents that share behavior across tasks in order to achieve success in tasks with sparse and delayed rewards. This process induces an inventory of reusable and interpretable subpolicies which can be employed for zero-shot generalization when further sketches are available, and hierarchical reinforcement learning when they are not.</p>
</blockquote>
<h2 id="parameter-sharing">Parameter sharing</h2>
<p>Convolutional and recurrent layers can be viewed as modular, in that they &ldquo;stamp&rdquo; a small neural network (with the same parameters) repeatedly in some pattern - repeated over space for CNNs, and repeated over time for RNNs.</p>
<h2 id="causal-learning">Causal learning</h2>
<p><a href="https://arxiv.org/abs/1909.10893"target="_blank">Recurrent Independent Mechanisms</a> (Goyal et al.)</p>
<blockquote>
<p>Physical processes in the world often have a modular structure which human cognition appears toexploit, with complexity emerging through combinations of simpler subsystems. Machine learningseeks to uncover and use regularities in the physical world. Although these regularities manifestthemselves as statistical dependencies, they are ultimately due to dynamic processes governed bycausal physical phenomena.</p>
</blockquote>
<blockquote>
<p>The notion of independent or autonomous mechanisms has been influential in the field of causal inference. A complex generative model, temporal or not, can be thought of as the composition of independent mechanisms or “causal” modules. In the causality community, this is often considered a prerequisite for being able to perform localized interventions upon variables determined by such models (Pearl, 2009). It has been argued that the individual modules tend to remain robust or invariant even as other modules change, e.g., in the case of distribution shift (Schölkopf et al., 2012; Peterset al., 2017). This independence is not between the random variables being processed but between the description or parametrization of the mechanisms: learning about one should not tell us anything about another, and adapting one should not require also adapting another. One may hypothesize that if a brain is able to solve multiple problems beyond a single i.i.d. (independent and identically distributed) task, they may exploit the existence of this kind of structure by learning independent mechanisms that can flexibly be reused, composed and re-purposed.</p>
</blockquote>
<p>An excerpt from Judea Pearl&rsquo;s book <a href="http://bayes.cs.ucla.edu/BOOK-2K/"target="_blank">Causality, 2nd ed.</a>. Pearl refers to &ldquo;mechanisms&rdquo; as the nodes in a Bayesian network (e.g. depicted in figure 1.2), which are assumed to be modular: i.e. they are internally isolated, apart from causation traveling along their arrows, and they are reusable in the sense that the graph can be modified, which Pearl calls an intervention.</p>
<p>

  <img src="https://danabo.github.io/blog/Pasted%20image%2020210413224425.png" alt="">
</p>
<blockquote>
<p>The example reveals a stronger sense in which causal relationships are more stable than the corresponding probabilistic relationships, a sense that goes beyond their basic ontological–epistemological difference. The relationship, “Turning the sprinkler on would not affect the rain,” will remain invariant to changes in the mechanism that regulates how seasons affect sprinklers. In fact, it remains invariant to changes in all mechanisms shown in this causal graph. We thus see that causal relationships exhibit greater robustness to ontological changes as well; they are sensitive to a smaller set of mechanisms. More specifically, and in marked contrast to probabilistic relationships, causal relationships remain invariant to changes in the mechanism that governs the causal variables ($X_3$ in our example).</p>
</blockquote>
<blockquote>
<p>Regardless of what use is eventually made  of our “understanding” of things, we surely would prefer an understanding in terms of durable relationships, transportable across situations, over those based on transitory relationships. The sense of “comprehensibility” that accompanies an adequate explanation is a natural by-product of the transportability of (and hence of our familiarity with) the causal relationships used in the explanation. It is for reasons of stability that we regard the falling barometer as predicting but not explaining the rain; those predictions are not transportable to situations where the pressure surrounding the barometer is controlled by artificial means. True understanding enables predictions in such novel situations, where some mechanisms change and others are added. It thus seems reasonable to suggest that, in the final analysis, the explanatory account of causation is merely a variant of the manipulative account, albeit one where interventions are dormant. Accordingly, we may as well view our unsatiated quest for understanding “how data is generated” or “how things work” as a quest for acquiring the ability to make predictions under a wider range of circumstances, including circumstances in which things are taken apart, reconfigured, or undergo spontaneous change.</p>
</blockquote>
<h2 id="program-induction-and-synthesis">Program induction and synthesis</h2>
<p><a href="https://arxiv.org/abs/1804.00218"target="_blank">HOUDINI: Lifelong Learning as Program Synthesis</a> (Valkov et al.)</p>
<blockquote>
<p>In contrast to standard methods for transfer learning in deep networks, which re-use the first few layers of the network, neural libraries have the potential to enable reuse of higher, more abstract levels of the network, in what could be called high-level transfer.</p>
</blockquote>
<blockquote>
<p>&hellip; our results indicate that the modular representation used in HOUDINI allows it to transfer high-level concepts and avoid negative transfer. We demonstrate that HOUDINI offers greater transfer than progressive neural networks and traditional “low-level” transfer, in which early network layers are inherited from previous tasks.</p>
</blockquote>
<p><a href="https://arxiv.org/abs/1909.13404"target="_blank">Towards modular and programmable architecture search</a> (Negrinho et al.)</p>
<blockquote>
<p>The building blocks of our search spaces are modules and hyper-parameters. Search spaces are created through the composition of modules and their interactions.Implementing a new module only requires dealing with aspects local to the module. Modules and hyperparameters can be reused across search spaces, and new search spaces can be written by combining existing search spaces.</p>
</blockquote>
<h1 id="how">How?</h1>
<p>How can modularity be achieved? Two things need to be simultaneously learned:</p>
<ol>
<li>The modules themselves.</li>
<li>How the modules are to be connected together.</li>
</ol>
<p>Key ideas:</p>
<ul>
<li><strong>Routing</strong>: How the modules are connected together.</li>
<li><strong>Dynamic</strong> vs <strong>static</strong> routing: Static routing is fixed for all inputs, while dynamic routing is conditioned on a given input or context. A router is a function that outputs module routing given context.</li>
<li><strong>Soft</strong> vs <strong>hard</strong> routing: Soft routing is a weighted sum across all choices, while hard routing is a single discrete choice. Soft routing is differentiable while hard routing is not.</li>
</ul>
<p>Examples of soft routing:</p>
<ul>
<li><a href="https://arxiv.org/abs/1410.5401"target="_blank">Neural Turing Machines</a> (Graves et al.)</li>
<li><a href="https://www.nature.com/articles/nature20101"target="_blank">Differentiable neural computers</a> (Graves et al.)</li>
<li><a href="https://arxiv.org/abs/1511.08228"target="_blank">Neural GPUs Learn Algorithms</a> (Kaiser et al.)</li>
</ul>
<p>Examples of hard routing:</p>
<ul>
<li><a href="https://arxiv.org/abs/1807.04640"target="_blank">Automatically Composing Representation Transformations as a Means for Generalization</a> (Chang et al.)</li>
<li><a href="https://arxiv.org/abs/1511.06392"target="_blank">Neural Random-Access Machines</a> (Kurach et al.)</li>
<li><a href="https://arxiv.org/abs/1511.07275"target="_blank">Learning Simple Algorithms from Examples</a> (Zaremba et al.)</li>
</ul>
<p>Is there something in between soft and hard routing?</p>
<ul>
<li><a href="https://arxiv.org/abs/1701.06538"target="_blank">Outrageously Large Neural Networks: The Sparsely-Gated Mixture-of-Experts Layer</a> (Shazeer et al.)</li>
<li><a href="https://arxiv.org/abs/1811.05249"target="_blank">Modular Networks: Learning to Decompose Neural Computation</a> (Kirsch et al.)</li>
</ul>
<h2 id="module-routing-in-detail">Module routing in detail</h2>
<p>Following the setup in <a href="https://arxiv.org/abs/1811.05249"target="_blank">Kirsch et al.</a>&hellip;</p>
<p>In the case of soft routing, think of module weights as probabilities. Instead of summing module outputs, sum probabilities of each possible output. This leads to a natural correspondence between soft and hard routing, where hard routing is sampled from the probability distribution.</p>
<p>In <a href="https://arxiv.org/abs/1811.05249"target="_blank">Kirsch et al.</a>, the choices are organized into layers, where for each layer $l$ a subset of $M$ modules are selected and their outputs are summed. In <a href="https://arxiv.org/abs/2003.04227"target="_blank">Abolafia et al.</a>, modules are connected into arbitrary computation graphs.</p>
<p>To keep things general, let $\mc{A}$ be a set of possible module routing choices, so that an element $a\in\mc{A}$ consists of all  choices needed for the architecture to produce an output (e.g. which modules to use in the computation graph and how they are connected).</p>
<p>Given a routing choice $a\in\mc{A}$, the architecture output probability given input $x$ and parameters $\t$ is</p>
<p>$$<br>
p(y\mid x,a,\t)\,.<br>
$$</p>
<p>Under the hood this output probability may be arrived at by combining the following components:</p>
<ol>
<li>A collection of differentiable functions (modules) $f_{\t\up{i}}\up{i} : \mc{Z}\up{i} \to \mc{Z}\up{j}$ where $\mc{Z}\up{i}$ and $\mc{Z}\up{j}$ are latent spaces (e.g. vectors in $\R^n$), and $\t\up{i}$ are the function parameters. Typically $\t = (\t\up{1},\t\up{2},\dots)$ and each module has independent and isolated parameters. The input $x$ may be initially encoded into a latent space, or some modules may have $\mc{Z} = \mc{X}$ and the data can be fed in directly.</li>
<li>A function $g$ that takes routing specification $a$, modules $\set{f_i}$, and input $x$, and outputs hidden representation $h$ (also a real vector).</li>
<li>A distribution &ldquo;head&rdquo; on output space $\mc{Y}$, s.t. $h$ represents the parameters of the distribution. For example, a Gaussian $\mc{N}(y \mid h)$ where $h$ encodes a vector of means and a covariance matrix.</li>
</ol>
<p>Putting these three things together produces the probability distribution $p(y\mid x,a,\t)$. Given training target $y$, this probability is fully differentiable w.r.t. $\t$ (typically given by the architecture as a <a href="https://en.wikipedia.org/wiki/Logit"target="_blank">logit</a>, or log-probability). If routing choice $a$ were held fixed, we can train this architecture with standard supervised techniques, e.g. with SGD. Furthermore, if $a\up{k}$ can be provided by some external hard-coded system given training example $(x\up{k}, y\up{k})$, then we can use SGD to maximize the dataset log-probability</p>
<p>$$<br>
\sum_{k=1}^N \log p(y\up{k}\mid x\up{k},a\up{k},\t)\,.<br>
$$</p>
<p>This is essentially the used in <a href="https://arxiv.org/abs/1807.04640"target="_blank">Chang et al.</a> and <a href="https://arxiv.org/abs/1511.02799"target="_blank">Andreas et al.</a>.</p>
<p>Ideally, we&rsquo;d like to learn the module routing $a\up{k}$ for each training example $(x\up{k}, y\up{k})$. That means learning a routing function, which produces a routing $a\up{k}$ given input $x\up{k}$. Assuming $\mc{A}$ is a discrete space (routing choices are discrete, e.g. which modules to pick and how to connect them), we cannot differentiate such a function. RL could be used, as in <a href="https://arxiv.org/abs/2003.04227"target="_blank">Abolafia et al.</a>, but <a href="https://arxiv.org/abs/1811.05249"target="_blank">Kirsch et al.</a> provides a more general perspective that allows for differentiation in principle, though intractable in practice.</p>
<p>Let the routing function output a probability distribution over $a\in\mc{A}$:</p>
<p>$$<br>
p(a \mid x, \p)<br>
$$</p>
<p>This router is comprised of a function $r_\p$, parameterized by parameters $\p$, that takes in $x$ and outputs a hidden representation $h'$ that, like before, holds the parameters for some probability distribution on $\mc{A}$ (e.g. Gaussian). If $a$ decomposes into a set of independent routing choices, e.g. $a=(a_1, a_2, \dots)$, then $p(a \mid x, \p) = \prod_t p(a_t \mid z_t, \p)$ where $\set{z_t}$ are potentially intermediate outputs from various modules, and at least one $z_t$ equals $x$.</p>
<p>This gives us a joint distribution on $y$ and $a$:</p>
<p>$$<br>
p(y, a \mid x,\t,\p) = p(y\mid x,a,\t)p(a\mid x, \p)\,.<br>
$$</p>
<p>To find the probability of $y$ given $x$, independent of routing choice $a$, we marginalize out $a$:</p>
<p>$$<br>
p(y \mid x, \t, \p) = \sum_{a\in\mc{A}} p(y\mid x,a,\t)p(a\mid x, \p)\,.<br>
$$</p>
<p>What this means in terms of training, is that if we are using naive SGD to maximize $\log p(y \mid x, \t, \p)$ w.r.t $\t$ and $\p$ jointly, then we simply sum over all possible routing choices in $\mc{A}$. In practice, this summation is intractable, since the number of routing decisions explodes as the number of modules is increased (as well as with other complexities like multi-input and multi-output modules).</p>
<p>We can view the same optimization through the lense of the REINFORCE algorithm, which naturally leads to RL optimization, where $p(a\mid x, \p)$ is the policy, $a$ are actions, and $x$ are environment observations. The reward function is then $R(a\mid x) = p(y\mid x,a,\t)$ (or the log-probability of $y$ like in <a href="https://arxiv.org/abs/1811.05249"target="_blank">Kirsch et al.</a>). Let the loss function $\mc{L} = p(y \mid x, \t, \p)$. Then the gradient $\nabla_\p \mc{L}$ is given using the <a href="https://dallascard.github.io/the-reinforce-trick.html"target="_blank">&ldquo;log-trick&rdquo;</a>:</p>
<p>$$<br>
\begin{aligned}<br>
\nabla_\p \mc{L} &amp;= \nabla_\p\E_{p(a\mid x, \p)}[p(y\mid x,a,\t)] \\<br>
&amp;= \nabla_\p\E_{p(a\mid x, \p)}[R(a \mid x)] \\<br>
&amp;= \E_{p(a\mid x, \p)}[\nabla_\p\log p(a\mid x, \p) R(a \mid x)]\,,<br>
\end{aligned}<br>
$$</p>
<p>which is the gradient as given in REINFORCE.</p>
<p>For the experiments in <a href="https://arxiv.org/abs/2003.04227"target="_blank">Abolafia et al.</a>, I found that scaling up episode collection as much as possible using <a href="https://arxiv.org/abs/1802.01561"target="_blank">IMPALA</a> partially overcame the usual issues associated with RL: sparse reward, high variance gradients, and lack of stability. Stability is especially an issue when the modules are being trained at the same time, so that the reward being optimized is a moving target. We were not able to jointly learn module and routing, so in <a href="https://arxiv.org/abs/2003.04227"target="_blank">Abolafia et al.</a> we settled for hard coded modules and focused on getting the router to work.</p>
<h2 id="other-kinds-of-training">Other kinds of training</h2>
<p><a href="https://arxiv.org/abs/1811.05249"target="_blank">Kirsch et al.</a> introduces a modified <a href="https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm"target="_blank">EM algorithm</a> for simultaneously training $\t$ and $\p$, where routing choice $a$ is the latent variable. As with EM, this is a two step iterative process, where joint probability of $a$ and $x$ is maximized with fixed $a$, and then $a$ is locally improved according to the current probability distribution. Rather than finding the argmax $a$, which is intractable, <a href="https://arxiv.org/abs/1811.05249"target="_blank">Kirsch et al.</a> samples an i.i.d. batch from $p(a \mid x, \p)$ and updates $a$ only if a higher probability $a$ is found.</p>
<p>This training algorithm can be viewed as performing policy gradient training (RL) with a &ldquo;top-$K$&rdquo; buffer, as described in <a href="https://arxiv.org/abs/1801.03526"target="_blank">Neural Program Synthesis with Priority Queue Training</a> (Abolafia 2018), where $K=1$.</p>
<p>Here is the general case of this training procedure:</p>
<p>Let $\tilde{A}_n$ be a length-$S$ i.i.d. sample from $p(a_n \mid x_n,\p)$.<br>
Let $A_n^*$ be a top-$K$ buffer for the $n$-th training example $(x\up{n},y\up{n})$. That means $A_n^*$ holds the best $a_n$ observed over the course of training, scored by $p(a_n \mid x_n,\p)$. Note that this is a moving target, since $\p$ is simultaneously changing, so the joint score of $A_n^*$ can decrease.<br>
Let $A_n = \tilde{A}_n \cup A_n^*$.  (If $A_n^* = \emptyset$ this reduces to usual policy gradient training, and if $\tilde{A}_n = \emptyset$ this reduces to the EM algorithm described above as well as <a href="https://arxiv.org/abs/1801.03526"target="_blank">Abolafia 2018</a>.)</p>
<p>Let $B \subseteq D$ be a minibatch. The Monte Carlo gradient approximation (ala REINFORCE) is:</p>
<p>$$<br>
\nabla_\p\mc{L} \approx \frac{1}{\abs{B}}\sum_{n\in B}\frac{1}{\abs{A_n}}\sum_{a_n \in A_n} \nabla_\p\log p(a\mid x, \p) R(a \mid x)<br>
$$</p>
<p>where $R(a\mid x) = p(y\mid x,a,\t)$ or $\log p(y\mid x,a,\t)$.</p>
<h3 id="information-theory">Information theory</h3>
<p><a href="https://arxiv.org/abs/1811.05249"target="_blank">Kirsch et al.</a> plots the quantities $H_a$ and $H_b$ as diagnostic tools and measures of &ldquo;module collapse&rdquo; and training convergence. I used the same quantities in my own experiments and found them to be similarly helpful.</p>
<p>There is theoretical justification for these quantities, and they may even be used as regularizers.</p>
<p>Let $A$ be the routing random variable and let $X$ be the input random variable, distributed jointly by $p(a \mid x, \p)p(x)$ where $p(x)$ is the true and unknown input distribution.</p>
<p>The mutual information between $A$ and $X$ decomposes:</p>
<p>$$<br>
\I(A, X) = \H(A) - \H(A \mid X)<br>
$$</p>
<p>We cannot explicitly compute these entropy terms because we do not have access to $p(x)$ or $p(a \mid \p)$.</p>
<p>Assume we can only explicitly compute $p(a \mid x, \p)$. Let&rsquo;s also suppose that we can explcitily compute $\H(A \mid X=x) = -\sum_{a\in\mc{A}} p(a \mid x, \p) \log p(a \mid x, \p)$. Though summing over $\mc{A}$ is still intractable, if we suppose that the routing distribution factors into independent choices which are themselves tractable to enumerate (like the choice for each layer in <a href="https://arxiv.org/abs/1811.05249"target="_blank">Kirsch et al.</a>): $\mc{A} = \mc{A}_1\times\mc{A}_2\times\dots$ and $a = (a_1, a_2, \dots) \in \mc{A}$ s.t.</p>
<p>$$<br>
p(a \mid x, \p) = \prod_{l=1}^L p(a_l \mid x, \p_l)\,,<br>
$$</p>
<p>then we can tractably compute the conditional entropy as the sum of entropies of each choice:</p>
<p>$$<br>
\begin{aligned}<br>
\H(A \mid X=x) &amp;= \sum_{l=1}^L \H(A_l \mid X=x) \\<br>
&amp;= \sum_{l=1}^L \sum_{a_l\in\mc{A}_l} p(a_l \mid x, \p_l) \log p(a_l \mid x, \p_l)\,.<br>
\end{aligned}<br>
$$</p>
<p>Now we can do a Monte Carlo approximation of the entropy terms of interest using the existing dataset. The statistical properties of this MC estimation is discussed in <a href="https://arxiv.org/abs/1905.06922"target="_blank">On Variational Bounds of Mutual Information</a>. Let $B \subseteq D$ be a minibatch uniformly sampled from dataset $D$.</p>
<p>$$<br>
\begin{aligned}<br>
\H(A \mid X) &amp;= -\E_{p(x)}[\H(Y\mid X=x)] \\<br>
&amp;\approx \frac{1}{\abs{B}}\sum_{n \in B} \H(Y\mid X=x_n)<br>
\end{aligned}<br>
$$</p>
<p>Letting $q(a \mid \p)$ be a Monte Carlo approximation of the marginal distribution $p(a\mid \p)$, derived from</p>
<p>$$<br>
\begin{aligned}<br>
p(a \mid \p) &amp;= \E_{p(x)}p(a \mid x, \p) \\ &amp;\approx \frac{1}{\abs{B}}\sum_{n \in B}p(a \mid x, \p) \\<br>
&amp;= q(a\mid \p)\,,<br>
\end{aligned}<br>
$$</p>
<p>we can approximate the marginal entropy,</p>
<p>$$<br>
\begin{aligned}<br>
\H(A) &amp;= -\E_{p(a \mid \p)}[\log p(a \mid \p)] \\<br>
&amp;\approx -\E_{q(a \mid \p)}[\log q(a\mid \p)]\,.<br>
\end{aligned}<br>
$$</p>
<p>We can think of $\I$ as measuring the bijectivness of the mapping from $x$ to $a$, where $\H(A)$ measures surjectivity and $\H(A\mid X)$ measures anti-injectivity. See <a href="http://zhat.io/articles/primer-shannon-information#expected-mutual-information">http://zhat.io/articles/primer-shannon-information#expected-mutual-information</a>.</p>
<p>$\H(A)$ measures module use. If its maximized, all the modules are getting used equally often.<br>
$\H(A\mid X)$ measures convergence. If its maximized, then the router is completely confident that there is exactly one appropriate routing choice for any given input.</p>
<p>The ideal is that all modules get used often and the router thinks there is one routing choice per input.</p>
<p>$\H(A)$ is a typical RL regularizer (called entropy regularization, see <a href="https://arxiv.org/abs/1602.01783"target="_blank">A3C</a>). However maximizing $\I(A,X)$ (where $x$ are env states) is uncommon. It may be unnecessary since $p(a \mid x)$ naturally becomes peaky over the course of training.</p>
</article><section class="article labels"><a class="tag" href=https://danabo.github.io/blog/tags/machine-learning/>machine learning</a></section>
</div><nav id="TableOfContents">
  <ol>
    <li><a href="#what">What?</a></li>
    <li><a href="#why">Why?</a>
      <ol>
        <li><a href="#data-invariances">Data invariances</a></li>
        <li><a href="#strong-generalization">Strong generalization</a></li>
        <li><a href="#parameter-sharing">Parameter sharing</a></li>
        <li><a href="#causal-learning">Causal learning</a></li>
        <li><a href="#program-induction-and-synthesis">Program induction and synthesis</a></li>
      </ol>
    </li>
    <li><a href="#how">How?</a>
      <ol>
        <li><a href="#module-routing-in-detail">Module routing in detail</a></li>
        <li><a href="#other-kinds-of-training">Other kinds of training</a>
          <ol>
            <li><a href="#information-theory">Information theory</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav></div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="https://danabo.github.io/blog/posts/bayesian-information-theory/"><span class="iconfont icon-article"></span>Bayesian information theory</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2021 Daniel Abolafia.</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p></div></section><script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({ 
                tex2jax: { 
                    inlineMath: [['$','$'], ['\\(','\\)']] 
                },

                "HTML-CSS": {
                    preferredFont: "TeX",
                    availableFonts: ["TeX"]
                }
            });
        </script></body>

</html>